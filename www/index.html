<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tron Game Client</title>
  </head>
  <body>
    <h1>Tron Game</h1>

    <!-- Login Section -->
    <div id="loginSection">
      <h2>Login</h2>
      <input
        type="text"
        id="pseudoInput"
        placeholder="Enter pseudo (3-20 chars)"
        maxlength="20"
      />
      <button onclick="login()">Login</button>
      <p id="loginStatus"></p>
    </div>

    <!-- Queue Section -->
    <div id="queueSection" style="display:none;">
      <h2>Matchmaking</h2>
      <button onclick="joinQueue()">Join Queue</button>
      <button onclick="leaveQueue()">Leave Queue</button>
      <p id="queueStatus"></p>
    </div>

    <!-- Game Section -->
    <div id="gameSection" style="display:none;">
      <h2>Game</h2>
      <p id="gameStatus"></p>
      <canvas id="gameCanvas" width="500" height="500"></canvas>
      <p>Use Arrow Keys to control</p>
      <div id="playersList"></div>
    </div>

    <!-- Stats Section -->
    <div id="statsSection" style="display:none;">
      <h2>Game Over</h2>
      <p id="winnerText"></p>
      <div id="rankings"></div>
      <button onclick="backToQueue()">Play Again</button>
    </div>

    <script>
          // Use relative URLs since we're served from the same origin
         const API_URL = 'http://127.0.0.1:9898/api';
      const WS_URL = `ws://127.0.0.1:9898`;

          let playerId = null;
          let pseudo = null;
          let ws = null;
          let currentRoom = null;
          let gameConfig = null;
          let canvas = null;
          let ctx = null;

          // Login
          async function login() {
              const input = document.getElementById('pseudoInput').value.trim();
              if (!input) return;

              try {
                  const res = await fetch(`${API_URL}/auth/login`, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ pseudo: input })
                  });

                  const data = await res.json();

                  if (res.ok) {
                      playerId = data.player.id;
                      pseudo = data.player.pseudo;
                      document.getElementById('loginStatus').textContent = `Logged in as ${pseudo}`;
                      document.getElementById('loginSection').style.display = 'none';
                      document.getElementById('queueSection').style.display = 'block';
                      connectWebSocket();
                  } else {
                      document.getElementById('loginStatus').textContent = data.message;
                  }
              } catch (error) {
                  document.getElementById('loginStatus').textContent = 'Connection error';
              }
          }

          // WebSocket
          function connectWebSocket() {
              ws = new WebSocket(`${WS_URL}?pseudo=${pseudo}`);

              ws.onopen = () => {
                  console.log('WebSocket connected');
              };

              ws.onmessage = (event) => {
                  const msg = JSON.parse(event.data);
                  handleWebSocketMessage(msg);
              };

              ws.onerror = (error) => {
                  console.error('WebSocket error:', error);
              };

              ws.onclose = () => {
                  console.log('WebSocket closed');
              };
          }

          function handleWebSocketMessage(msg) {
              console.log('Received:', msg);

              switch(msg.type) {
                  case 'HELLO_ACK':
                      gameConfig = msg.config;
                      break;

                  case 'QUEUE_ACK':
                      document.getElementById('queueStatus').textContent =
                          `In queue (${msg.queueSize} players)`;
                      break;

                  case 'QUEUE_STATUS':
                      document.getElementById('queueStatus').textContent =
                          `Position: ${msg.position}/${msg.size}`;
                      break;

                  case 'QUEUE_LEFT':
                      document.getElementById('queueStatus').textContent = 'Left queue';
                      break;

                  case 'MATCH_FOUND':
                      currentRoom = msg.roomId;
                      document.getElementById('queueStatus').textContent = 'Match found!';
                      break;

                  case 'GAME_STARTING':
                      showGameSection();
                      setupCanvas(msg.config);
                      displayPlayers(msg.players);
                      document.getElementById('gameStatus').textContent =
                          `Game starting in ${msg.countdown}s...`;
                      break;

                  case 'GAME_STARTED':
                      document.getElementById('gameStatus').textContent = 'Game in progress';
                      break;

                  case 'GAME_STATE':
                      renderGame(msg.data);
                      break;

                  case 'PLAYER_ELIMINATED':
                      document.getElementById('gameStatus').textContent =
                          `${msg.pseudo} eliminated (${msg.reason}). ${msg.remainingPlayers} left`;
                      break;

                  case 'GAME_OVER':
                      showGameOver(msg);
                      break;

                  case 'ERROR':
                      alert(`Error: ${msg.message}`);
                      break;
              }
          }

          // Queue
          function joinQueue() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({ type: 'JOIN_QUEUE' }));
              }
          }

          function leaveQueue() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({ type: 'LEAVE_QUEUE' }));
              }
          }

          // Game Display
          function showGameSection() {
              document.getElementById('queueSection').style.display = 'none';
              document.getElementById('gameSection').style.display = 'block';
              document.getElementById('statsSection').style.display = 'none';
          }

          function setupCanvas(config) {
              canvas = document.getElementById('gameCanvas');
              ctx = canvas.getContext('2d');

              const cellSize = Math.min(
                  canvas.width / config.largeur,
                  canvas.height / config.hauteur
              );

              canvas.width = config.largeur * cellSize;
              canvas.height = config.hauteur * cellSize;
          }

          function displayPlayers(players) {
              const list = document.getElementById('playersList');
              list.innerHTML = '<h3>Players:</h3>' + players.map(p =>
                  `<p style="color:${p.color}">${p.pseudo}</p>`
              ).join('');
          }

          function renderGame(state) {
              if (!canvas || !ctx) return;

              const cellW = canvas.width / state.config.largeur;
              const cellH = canvas.height / state.config.hauteur;

              // Clear canvas
              ctx.fillStyle = '#000';
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              // Draw players
              state.players.forEach(player => {
                  ctx.fillStyle = player.color;
                  ctx.fillRect(
                      player.x * cellW,
                      player.y * cellH,
                      cellW,
                      cellH
                  );
              });
          }

          // Controls
          document.addEventListener('keydown', (e) => {
              if (!ws || ws.readyState !== WebSocket.OPEN || !currentRoom) return;

              let direction = null;

              switch(e.key) {
                  case 'ArrowUp':
                      direction = 'UP';
                      break;
                  case 'ArrowDown':
                      direction = 'DOWN';
                      break;
                  case 'ArrowLeft':
                      direction = 'LEFT';
                      break;
                  case 'ArrowRight':
                      direction = 'RIGHT';
                      break;
              }

              if (direction) {
                  e.preventDefault();
                  ws.send(JSON.stringify({
                      type: 'PLAYER_INPUT',
                      direction: direction
                  }));
              }
          });

          // Game Over
          function showGameOver(msg) {
              document.getElementById('gameSection').style.display = 'none';
              document.getElementById('statsSection').style.display = 'block';

              document.getElementById('winnerText').textContent =
                  msg.winner ? `Winner: ${msg.winner}` : 'Draw!';

              const rankings = document.getElementById('rankings');
              rankings.innerHTML = '<h3>Rankings:</h3>' +
                  msg.rankings.map(r =>
                      `<p>${r.position}. ${r.pseudo} - ${(r.survivalTime / 1000).toFixed(1)}s</p>`
                  ).join('');

              currentRoom = null;
          }

          function backToQueue() {
              document.getElementById('statsSection').style.display = 'none';
              document.getElementById('queueSection').style.display = 'block';
          }

          // Allow Enter key for login
          document.getElementById('pseudoInput').addEventListener('keypress', (e) => {
              if (e.key === 'Enter') login();
          });
    </script>
  </body>
</html>
